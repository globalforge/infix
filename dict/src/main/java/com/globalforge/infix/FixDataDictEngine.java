package com.globalforge.infix;

import java.io.FileInputStream;
import java.io.InputStream;
import org.antlr.v4.runtime.CharStreams;
import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.tree.ParseTree;
import org.antlr.v4.runtime.tree.ParseTreeWalker;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import com.globalforge.infix.antlr.XMLLexer;
import com.globalforge.infix.antlr.XMLParser;

/*-
 The MIT License (MIT)

 Copyright (c) 2019-2020 Global Forge LLC

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */
/**
 * Stage 2 in the infix application. After the FixRepositoryParser is run this
 * program is run once for each xml file produced by the FixRepositoryParser.
 * Function: Parses the XML output generated by the FixRepositoryParser and
 * generates Java source encapulating the data from the xml file into a series
 * of classes representing repeating groups. These classes are needed by the
 * runtime infix engine in order to determine what context a tag is in (e.g., a
 * repeating group or stand alone) within any message type when parsing a fix
 * string. Unlike the FixRepositoryParser this class uses an xml parser
 * generated by Antlr. See the build scripts for details.
 *
 * @see FixRepositoryParser
 * @author Michael
 */
public class FixDataDictEngine {
    /** logger */
    final static Logger logger = LoggerFactory
        .getLogger(FixDataDictEngine.class);
    // create a CharStream that reads from standard input
    private CharStream input = null;
    // create a lexer that feeds off of input CharStream
    private XMLLexer lexer = null;
    // create a buffer of tokens pulled from the lexer
    private CommonTokenStream tokens = null;
    // create a parser that feeds off the tokens buffer
    private XMLParser parser = null;
    private ParseTree tree = null;
    private String fixVersion = null;

    public FixDataDictEngine(String version) throws Exception {
        fixVersion = version;
        initInputStreams();
        parseRules();
    }

    /**
     * The program needs to know where to locate the xml files
     *
     * @throws Exception xml files can not be loaded.
     */
    private void initInputStreams() throws Exception {
        String CONFIG_DIR = System.getenv("CONFIG_DIR");
        if (CONFIG_DIR != null) {
            logger.info("CONFIG_DIR is an ENV variable: {}", CONFIG_DIR);
        } else {
            CONFIG_DIR = System.getProperty("CONFIG_DIR");
            if (CONFIG_DIR != null) {
                logger.info("CONFIG_DIR is a System property: {}", CONFIG_DIR);
            } else {
                CONFIG_DIR = null;
            }
        }
        if (CONFIG_DIR == null) {
            CONFIG_DIR = System.getProperty("user.dir");
            logger.warn(
                "No CONFIG_DIR provided.  Output stream is user.dir: {}",
                CONFIG_DIR);
        } else {
            String inFileName =
                CONFIG_DIR + System.getProperty("file.separator") + fixVersion
                    + "Mgr.xml";
            InputStream in = new FileInputStream(inFileName);
            input = CharStreams.fromStream(in);
            lexer = new XMLLexer(input);
            tokens = new CommonTokenStream(lexer);
            parser = new XMLParser(tokens);
        }
    }

    /**
     * Captures the parse tree for debug purposes.
     */
    private void parseRules() {
        tree = parser.document();
    }

    /**
     * The main entry point.
     *
     * @see FixDataDictListener
     * @param fixVersion The fix version xml file we are parsing.
     * @throws Exception XML file can not be loaded.
     */
    public void codeGen(String fixVersion) throws Exception {
        ParseTreeWalker walker = new ParseTreeWalker(); // create standard
                                                        // walker
        FixDataDictListener extractor = new FixDataDictListener(fixVersion);
        walker.walk(extractor, tree); // initiate walk of tree with listener
    }

    @Override
    public String toString() {
        return tree.toStringTree(parser); // print LISP-style tree
    }

    public static void main(String[] args) {
        try {
            String outPath = System.getProperty("src.dir");
            logger.info("src.dir: {}", outPath);
            if (args.length == 0) {
                logger.error("Must provide an args[0] from the following set:");
                logger.error("FIX.4.0");
                logger.error("FIX.4.1");
                logger.error("FIX.4.2");
                logger.error("FIX.4.3");
                logger.error("FIX.4.4");
                logger.error("FIX.5.0");
                logger.error("FIX.5.0SP1");
                logger.error("FIX.5.0SP2");
                logger.error("FIXT.1.1");
                System.exit(-1);
            }
            String fixVersion = args[0];
            FixDataDictEngine eng = new FixDataDictEngine(fixVersion);
            eng.codeGen(fixVersion);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
